var documenterSearchIndex = {"docs":
[{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = Monadic","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"@monadic\n@pure","category":"page"},{"location":"library/#Monadic.@monadic","page":"Library","title":"Monadic.@monadic","text":"myflatmap(f, x) = Iterators.flatten(map(f, x))\niteratorresult = @monadic map myflatmap begin\n  x = 1:3\n  y = [1, 6]\n  @pure x + y\nend\ncollect(iteratorresult)  # [2, 7, 3, 8, 4, 9]\n\nThe monadic allows a syntax where containers and other contexts are treated rather as values, hiding the respective well-defined side-effects. Each line without @pure is regarded as a container, each line with @pure is treated as normal code which should be inlined.\n\nFor the example above you see that the side-effect semantics of iterables are the same as for nested for loops. With the crucial distinction, that the @monadic syntax has a return value.\n\n\n\n@monadic can take a third argument wrapper in order to first apply a custom function before executing the @monadic code.\n\nmywrapper(n::Int) = 1:n\nmywrapper(any) = any\nmyflatmap(f, x) = Iterators.flatten(map(f, x))\niteratorresult = @monadic map myflatmap mywrapper begin\n  x = 3\n  y = [1, 6]\n  @pure x + y\nend\ncollect(iteratorresult)  # [2, 7, 3, 8, 4, 9]\n\n\n\n\n\n","category":"macro"},{"location":"library/#Monadic.@pure","page":"Library","title":"Monadic.@pure","text":"Mark code to contain non-monadic code.\n\nThis can be thought of as generalized version of pure typeclass.\n\n\n\n\n\n","category":"macro"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To load this package just run using Monadic. It will give you the one and only macro @monadic and its little helper @pure.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"With both you can define custom monadic syntax, let's look at an example to clarifiy what this means.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"my_map(f, a::Vector) = f.(a)\nmy_flatmap(f, a::Vector) = vcat(f.(a)...)\n# to show you what flatmap does, a small example\nmy_flatmap(x -> [x, x], [1, 2])  # [1, 1, 2, 2]  i.e. it applies `f` to every element and concatenates all results\n\nusing Monadic\n@monadic my_map my_flatmap begin\n  a = [:a,:b]\n  b = [1, 2]\n  c = [b + 4, b + 5]\n  @pure Symbol(a, b, c)\nend\n\n# output\n\n8-element Array{Symbol,1}:\n :a15\n :a16\n :a26\n :a27\n :b15\n :b16\n :b26\n :b27","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Apparently, this use of @monadic works like a nested for-loop, collecting the results.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To summarize what happens is that each line is interpreted as a kind of context or context-assignment (instead of a usual value or value assignment in normal syntax). With the @pure macro you can indicate that the code should be  interpreted normally (without context).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The context here is defined by our Vector, which we interpreted by my_map and my_flatmap as a kind of \"do the computation for all combinations\". It is like a context for indeterminism.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"So let's read the @monadic syntax out loud:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"for every a in [:a, :b]\nfor every b in [1, 2]\nfor every c in [b + 4, b + 5]\ndo a normal computation `Symbol(a, b, c)` (because it is prepended with `@pure`)\nand collect the last computation for all combinations (because it is the last expression)","category":"page"},{"location":"manual/#Using-a-wrapper-as-a-third-argument","page":"Manual","title":"Using a wrapper as a third argument","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"In addition, @monadic supports a little helper in order to initially apply a given function to all containers, before executing the standard @monadic semantics.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"my_wrapper(i::Int) = collect(1:i)\nmy_wrapper(other) = other\n\n@monadic my_map my_flatmap my_wrapper begin\n  a = 2\n  b = a + 2\n  @pure (a, b)\nend\n\n# output\n\n7-element Array{Tuple{Int64,Int64},1}:\n (1, 1)\n (1, 2)\n (1, 3)\n (2, 1)\n (2, 2)\n (2, 3)\n (2, 4)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This is equivalent to just calling the wrapper everywhere yourself","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@monadic my_map my_flatmap begin\n  a = my_wrapper(2)\n  b = my_wrapper(a + 2)\n  @pure (a, b)\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Together, with only three functions my_map, my_flatmap and my_wrapper, this gives you a compact and well-defined way to specify your own domain specific language.","category":"page"},{"location":"manual/#How-does-it-do-it?","page":"Manual","title":"How does it do it?","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's inspect it with @macroexpand","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@macroexpand @monadic my_map my_flatmap begin\n  a = [:a,:b]\n  b = [1, 2]\n  c = [b + 4, b + 5]\n  @pure Symbol(a, b, c)\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"which shows that it is translated to the following code","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(my_flatmap)(((a,)->begin\n   (my_flatmap)(((b,)->begin\n       (my_map)(((c,)->begin\n           #= none:9 =#\n           Symbol(a, b, c)\n       end), [b + 4, b + 5])\n   end), [1, 2])\nend), [:a, :b])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You see, it is just a nested call of my_flatmap and my_map. More concretely, for all but the last = sign my_flatmap is used and finally my_map.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can easily check that this corresponds to a nested for-loop, which collects all results flat in one final array.","category":"page"},{"location":"manual/#The-use-of-@pure","page":"Manual","title":"The use of @pure","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Some more example will help to better understand how the syntax works in detail. @pure can be placed at any row and will just bring you back to normal semantics.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@monadic my_map my_flatmap begin\n  a = [1, 3]\n  @pure b = a + 6\n  c = [b, b, b]\n  @pure c\nend\n\n# output\n\n6-element Array{Int64,1}:\n 7\n 7\n 7\n 9\n 9\n 9","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Inspecting the macro with @macroexpand again shows that the @pure statement is now inlined into the respective my_flatmap (in the first example it was kind of inlined into the last call of my_map).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(my_flatmap)(((a,)->begin\n   b = a + 6\n   (my_map)(((c,)->begin\n       c\n   end), [b, b, b])\nend), [1, 3])","category":"page"},{"location":"manual/#The-last-value","page":"Manual","title":"The last value","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The very last statement in a monadic code block has a special meaning as we already saw in the introductory example. For our Vector example, the last expression was the one which got collected. It my look like you always have to use @pure in the last row. You don't have to actually.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In fact, the last example can be simplified to the following","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@monadic my_map my_flatmap begin\n  a = [1, 3]\n  @pure b = a + 6\n  [b, b, b]\nend\n\n# output\n\n6-element Array{Int64,1}:\n 7\n 7\n 7\n 9\n 9\n 9","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's again look what this translates to","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(my_flatmap)(((a,)->begin\n    b = a + 6\n    [b, b, b]\nend), [1, 3])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You see the code is much simpler than before, the last use of my_map is completely dropped and what we previously called c is now directly returned. You can understand the last @pure respectively as \"execute this on the final context\", hence the need for my_map.","category":"page"},{"location":"manual/#Using-other-functions-instead-of-map-and-flatmap","page":"Manual","title":"Using other functions instead of map and flatmap","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can define your own versions of my_map and my_flatmap, creating whatever context you would like. You can even use the syntax in a different way by not sticking to the semantics of map and flatmap for your functions.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"A simple example would be to use my_map twice","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@monadic my_map my_map begin\n  a = [:a,:b]\n  b = [1, 2]\n  c = [b + 4, b + 5]\n  @pure Symbol(a, b, c)\nend\n\n# output\n\n2-element Array{Array{Array{Symbol,1},1},1}:\n [[:a15, :a16], [:a26, :a27]]\n [[:b15, :b16], [:b26, :b27]]","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"here you can clearly see the nestings, which usually get flattened out when using my_flatmap instead.","category":"page"},{"location":"manual/#Implementation-Details","page":"Manual","title":"Implementation Details","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"This implementation intentionally uses map and flatmap, and not a kind of pure and flatmap. One reason is that map is already well known and defined for almost everything. A second reason is that there are practical DataStructures for which you can define map but not pure (e.g. Dict if interpreted as Dict{Context} functor as in Scala, or the writer functor Pair{Context}.)","category":"page"},{"location":"#Monadic.jl","page":"Home","title":"Monadic.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides the macro @monadic and its little helper @pure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"With both you can define custom monadic syntax, let's look at an example to clarifiy what this means.","category":"page"},{"location":"","page":"Home","title":"Home","text":"my_map(f, a::Vector) = f.(a)\nmy_flatmap(f, a::Vector) = vcat(f.(a)...)\n# to show you what flatmap does, a small example\nmy_flatmap(x -> [x, x], [1, 2])  # [1, 1, 2, 2]  i.e. it applies `f` to every element and concatenates all results\n\nusing Monadic\n@monadic my_map my_flatmap begin\n  a = [:a,:b]\n  b = [1, 2]\n  c = [b + 4, b + 5]\n  @pure Symbol(a, b, c)\nend\n# returns [:a15, :a16, :a26, :a27, :b15, :b16, :b26, :b27]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Apparently, this use of @monadic works like a nested for-loop, collecting the results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To summarize what happens is that each line is interpreted as a kind of context or context-assignment (instead of a usual value or value assignment in normal syntax). With the @pure macro you can indicate that the code should be  interpreted normally (without context).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The context here is defined by our Vector, which we interpreted by my_map and my_flatmap as a kind of \"do the computation for all combinations\". It is like a context for indeterminism.","category":"page"},{"location":"","page":"Home","title":"Home","text":"So let's read the @monadic syntax out loud:","category":"page"},{"location":"","page":"Home","title":"Home","text":"for every a in [:a, :b]\nfor every b in [1, 2]\nfor every c in [b + 4, b + 5]\ndo a normal computation `Symbol(a, b, c)` (because it is prepended with `@pure`)\nand collect the last computation for all combinations (because it is the last expression)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, use the following command inside the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Monadic\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load the package, use the command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Monadic","category":"page"},{"location":"","page":"Home","title":"Home","text":"It will give you the macros @monadic and @pure.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Library Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]","category":"page"}]
}
