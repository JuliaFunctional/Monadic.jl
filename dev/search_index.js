var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Monadic","category":"page"},{"location":"#Monadic","page":"Home","title":"Monadic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Monadic]","category":"page"},{"location":"#Monadic.PureCode","page":"Home","title":"Monadic.PureCode","text":"Simple helper type to mark pure code parts in monadic code block\n\n\n\n\n\n","category":"type"},{"location":"#Monadic.@monadic-Tuple{Any,Any,Any}","page":"Home","title":"Monadic.@monadic","text":"myflatmap(f, x) = Iterators.flatten(map(f, x))\niteratorresult = @monadic map myflatmap begin\n  x = 1:3\n  y = [1, 6]\n  @pure x + y\nend\ncollect(iteratorresult)  # [2, 7, 3, 8, 4, 9]\n\nThe monadic allows a syntax where containers and other contexts are treated rather as values, hiding the respective well-defined side-effects. Each line without @pure is regarded as a container, each line with @pure is treated as normal code which should be inlined.\n\nFor the example above you see that the side-effect semantics of iterables are the same as for nested for loops. With the crucial distinction, that the @monadic syntax has a return value.\n\n\n\n@monadic can take a third argument wrapper in order to first apply a custom function before executing the @monadic code.\n\nmywrapper(n::Int) = 1:n\nmywrapper(any) = any\nmyflatmap(f, x) = Iterators.flatten(map(f, x))\niteratorresult = @monadic map myflatmap mywrapper begin\n  x = 3\n  y = [1, 6]\n  @pure x + y\nend\ncollect(iteratorresult)  # [2, 7, 3, 8, 4, 9]\n\n\n\n\n\n","category":"macro"},{"location":"#Monadic.@pure-Tuple{Any}","page":"Home","title":"Monadic.@pure","text":"Mark code to contain non-monadic code.\n\nThis can be thought of as generalized version of pure typeclass.\n\n\n\n\n\n","category":"macro"}]
}
